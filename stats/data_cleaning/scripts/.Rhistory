}
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- participant_ID
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
## Initiate function called score_questionnaire that accepts a single argument called `data`. Within this function...
score_questionnaire <- function(data) {
## Extract questionnaire data cell
json_data <- data[data$trialType == "Questionnaire", "response"]
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
questionnaire <- as.data.frame(questionnaire)
str(questionnaire) # checking my work
## Convert to numeric
questionnaire <- as.data.frame(lapply(questionnaire, as.numeric))
## No reverse-scoring because unnecessary
## Calculate & return questionnaire score (mean)
score <- rowMeans(questionnaire, na.rm = TRUE)
}
## Extract questionnaire data cell
json_data <- data[data$trialType == "Questionnaire", "response"]
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
questionnaire <- as.data.frame(questionnaire)
str(questionnaire) # checking my work
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
## Calculate & return questionnaire score (mean)
score <- rowMeans(questionnaire, na.rm = TRUE)
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- participant_ID
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
## Initiate a for loop that iterates across each file in files_list
for (file_list in files_list) {
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- participant_ID
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
}
## Change column "whichPrime" to be a factor (should have 2 or 3 levels depending on your prime)
dScores$whichPrime <- as.factor(dScores$whichPrime)
## Change "d_score" and "questionnaire" to be numbers
dScores$d_score <- as.numeric(dScores$d_score)
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
print(json_data)
print(json_data)
## Extract questionnaire data cell
json_data <- data[data$trialType == "questionnaire", "response"]
print(json_data)
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
questionnaire <- as.data.frame(questionnaire)
str(questionnaire) # checking my work
## Convert to numeric
questionnaire <- as.data.frame(lapply(questionnaire, as.numeric))
## Calculate & return questionnaire score (mean)
score <- rowMeans(questionnaire, na.rm = TRUE)
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- participant_ID
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
## Change "participant_ID" to be characters
dScores$participant_ID <- as.character(dScores$participant_ID)
## Change "d_score" and "questionnaire" to be numbers
dScores$d_score <- as.numeric(dScores$d_score)
## Change column "whichPrime" to be a factor (should have 2 or 3 levels depending on your prime)
dScores$whichPrime <- as.factor(dScores$whichPrime)
dScores$questionnaire <- as.numeric(dScores$questionnaire)
View(questionnaire)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
return(score)
## Initiate function called score_questionnaire that accepts a single argument called `data`. Within this function...
score_questionnaire <- function(data) {
## Extract questionnaire data cell
json_data <- data[data$trialType == "questionnaire", "response"]
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
questionnaire <- as.data.frame(questionnaire)
str(questionnaire) # checking my work
## Convert to numeric
questionnaire <- as.data.frame(lapply(questionnaire, as.numeric))
## No reverse-scoring because unnecessary
## Calculate & return questionnaire score (mean)
score <- rowMeans(questionnaire, na.rm = TRUE)
return(score)
}
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
## Initiate a for loop that iterates across each file in files_list
for (file_list in files_list) {
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- participant_ID
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
}
## Change column "whichPrime" to be a factor (should have 2 or 3 levels depending on your prime)
dScores$whichPrime <- as.factor(dScores$whichPrime)
## Change "d_score" and "questionnaire" to be numbers
dScores$d_score <- as.numeric(dScores$d_score)
dScores$questionnaire <- as.numeric(dScores$questionnaire)
## Change "participant_ID" to be characters
dScores$participant_ID <- as.character(dScores$participant_ID)
## Outside of the for loop, save the new dScores data frame using write.csv() into your data_cleaning/data subdirectory:
write.csv(dScores,"~/Desktop/psy1903/stats/data_cleaning/data/participant_dScores.csv", row.names = FALSE)
# Practice: read in data
data <- read.csv("~/Desktop/psy1903/osfstorage-archive/eco-emotions-2024-11-05-21-43-21.csv", header = TRUE, na.strings = "NA")
data$rt <- round(as.numeric(data$rt), 0)
# Step 1: Specify your function with one argument, data
calculate_IAT_dscore <- function(data) {
# Step 2: Only select trials with rt > 300 & < 5000 and filter correct trials (subset full data frame into new data frame called tmp)
tmp <- data[data$rt > 300 & data$rt < 5000, ]
tmp <- tmp[tmp$correct == "true", ]
# Step 3: Separate congruent and incongruent trials (subset tmp into two new data frames: congruent_trials and incongruent_trials)
congruent_trials <- tmp[tmp$expectedCategoryAsDisplayed == "nature or serenity" | tmp$expectedCategoryAsDisplayed == "school or anxiety", ]
incongruent_trials <- tmp[tmp$expectedCategoryAsDisplayed == "nature or anxiety" | tmp$expectedCategoryAsDisplayed == "school or serenity", ]
# Step 4: Calculate mean for congruent & incongruent trials (mean_congruent, mean_incongruent)
mean_congruent <- mean(congruent_trials$rt, na.rm = TRUE)
mean_incongruent <- mean(incongruent_trials$rt, na.rm = TRUE)
# Step 5: Calculate standard deviation for all trials (pooled_sd)
pooled_sd <- sd(tmp$rt, na.rm = TRUE)
# Step 6: Calculate D-score
d_score <- (mean_incongruent - mean_congruent) / pooled_sd
# Step 7: Return D-score
return(d_score)
}
## Initiate function called score_questionnaire that accepts a single argument called `data`. Within this function...
score_questionnaire <- function(data) {
## Extract questionnaire data cell
json_data <- data[data$trialType == "questionnaire", "response"]
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
questionnaire <- as.data.frame(questionnaire)
str(questionnaire) # checking my work
## Convert to numeric
questionnaire <- as.data.frame(lapply(questionnaire, as.numeric))
## No reverse-scoring because unnecessary
## Calculate & return questionnaire score (mean)
score <- rowMeans(questionnaire, na.rm = TRUE)
return(score)
}
## Set a variable called directory_path with the path to the location of your data csv files. This directory should *only* contain your raw participant csv data files and no other files.
directory_path <- "~/Desktop/psy1903/osfstorage-archive"
## Create a list of all the files in that directory.
files_list <- list.files(path = directory_path, pattern = "\\.csv$", full.names = TRUE)
## Create an empty data frame called dScores that has two columns & as many rows as you have data files (e.g., participants)
dScores <- data.frame(matrix(nrow = length(files_list), ncol = 2))
## Rename the default column names to something meaningful
colnames(dScores) <- c("participant_ID", "d_score")
## Initiate variable i to represent row numbers for each iteration, starting with 1
i = 1
## Initiate a for loop that iterates across each file in files_list
for (file_list in files_list) {
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- tmp$whichPrime
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
}
View(dScores)
# Practice: read in data
data <- read.csv("~/Desktop/psy1903/osfstorage-archive/eco-emotions-2024-11-05-21-43-21.csv", header = TRUE, na.strings = "NA")
data$rt <- round(as.numeric(data$rt), 0)
# Step 1: Specify your function with one argument, data
calculate_IAT_dscore <- function(data) {
# Step 2: Only select trials with rt > 300 & < 5000 and filter correct trials (subset full data frame into new data frame called tmp)
tmp <- data[data$rt > 300 & data$rt < 5000, ]
tmp <- tmp[tmp$correct == TRUE, ]
# Step 3: Separate congruent and incongruent trials (subset tmp into two new data frames: congruent_trials and incongruent_trials)
congruent_trials <- tmp[tmp$expectedCategoryAsDisplayed == "nature or serenity" | tmp$expectedCategoryAsDisplayed == "school or anxiety", ]
incongruent_trials <- tmp[tmp$expectedCategoryAsDisplayed == "nature or anxiety" | tmp$expectedCategoryAsDisplayed == "school or serenity", ]
# Step 4: Calculate mean for congruent & incongruent trials (mean_congruent, mean_incongruent)
mean_congruent <- mean(congruent_trials$rt, na.rm = TRUE)
mean_incongruent <- mean(incongruent_trials$rt, na.rm = TRUE)
# Step 5: Calculate standard deviation for all trials (pooled_sd)
pooled_sd <- sd(tmp$rt, na.rm = TRUE)
# Step 6: Calculate D-score
d_score <- (mean_incongruent - mean_congruent) / pooled_sd
# Step 7: Return D-score
return(d_score)
}
## Initiate function called score_questionnaire that accepts a single argument called `data`. Within this function...
score_questionnaire <- function(data) {
## Extract questionnaire data cell
json_data <- data[data$trialType == "questionnaire", "response"]
## Use fromJSON to convert from JSON to data frame
questionnaire <- fromJSON(json_data)
questionnaire <- as.data.frame(questionnaire)
str(questionnaire) # checking my work
## Convert to numeric
questionnaire <- as.data.frame(lapply(questionnaire, as.numeric))
## No reverse-scoring because unnecessary
## Calculate & return questionnaire score (mean)
score <- rowMeans(questionnaire, na.rm = TRUE)
return(score)
}
## Set a variable called directory_path with the path to the location of your data csv files. This directory should *only* contain your raw participant csv data files and no other files.
directory_path <- "~/Desktop/psy1903/osfstorage-archive"
## Create a list of all the files in that directory.
files_list <- list.files(path = directory_path, pattern = "\\.csv$", full.names = TRUE)
## Create an empty data frame called dScores that has two columns & as many rows as you have data files (e.g., participants)
dScores <- data.frame(matrix(nrow = length(files_list), ncol = 2))
## Rename the default column names to something meaningful
colnames(dScores) <- c("participant_ID", "d_score")
## Initiate variable i to represent row numbers for each iteration, starting with 1
i = 1
## Initiate a for loop that iterates across each file in files_list
for (file_list in files_list) {
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- tmp$whichPrime
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
}
View(tmp)
View(dScores)
## Initiate variable i to represent row numbers for each iteration, starting with 1
i = 1
## Initiate a for loop that iterates across each file in files_list
for (file_list in files_list) {
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- tmp$whichPrime
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
}
files_list[[1]]
file <- files_list[[1]]
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
str(trmp)
str(tmp)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
data[, factorCategory] <- as.factor(data[, factorCategory])
}
str(tmp)
for (factorCategory in factorList) {
tmp[, factorCategory] <- as.factor(tmp[, factorCategory])
}
str(tmp)
str(tmp$leftCategory)
??as.factor
help(as.factor)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
tmp[, factorCategory] <- as.factor(tmp[, factorCategory], exclude = "")
}
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
tmp[, factorCategory] <- as.factor(tmp[, factorCategory], exclude = "")
}
str(tmp)
for (factorCategory in factorList) {
tmp[, factorCategory] <- as.factor(tmp[, factorCategory], exclude = NA)
}
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
str(tmp)
for (factorCategory in factorList) {
tmp[tmp != "", factorCategory] <- as.factor(tmp[tmp != "", factorCategory])
}
for (factorCategory in factorList) {
tmp[, factorCategory] <- as.factor(tmp[, factorCategory])
}
str(tmp)
View(tmp)
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
i
tmp$whichPrime
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- tmp[tmp$trialType == "prime" ,"whichPrime"]
calculate_IAT_dscore(tmp)
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
## Initiate a for loop that iterates across each file in files_list
for (file_list in files_list) {
# Use read.csv to read in your file as a temporary data frame
tmp <- read.csv(file_list)
# Convert 'rt' from character to numeric and round it
tmp$rt <- round(as.numeric(tmp$rt), 0)
# Convert "correct" column to logical
tmp$correct <- as.logical(tmp$correct)
# Converting some columns to factors via another for loop
factorList <- c("expectedCategory", "expectedCategoryAsDisplayed", "leftCategory", "rightCategory")
for (factorCategory in factorList) {
tmp[, factorCategory] <- as.factor(tmp[, factorCategory])
}
# Check for NAs (non-numeric values) and handle them
if (any(is.na(tmp$rt))) {
warning(paste("NAs introduced by coercion in participant", tools::file_path_sans_ext(basename(file_list))))
}
# Assign participant_ID as the base name of the file
participant_ID <- tools::file_path_sans_ext(basename(file_list))
# Isolate the participant_ID column for the current row number (i) and assign it to be the current participant_ID variable
dScores[i, "participant_ID"] <- participant_ID
# Assign the dScores "whichPrime" column to be the current participant's prime label
dScores[i, "whichPrime"] <- tmp[tmp$trialType == "prime" ,"whichPrime"]
# Isolate the d_score column for the current row number (i) and assign it to be the current d-score by using calculate_IAT_dscore on the tmp data file
dScores[i, "d_score"] <- calculate_IAT_dscore(tmp)
# Assign the "questionnaire" column to be the output of the score_questionnaire function
dScores[i, "questionnaire"] <- score_questionnaire(tmp)
# Remove the temporary data file tmp
rm(tmp)
# Increase our row number variable i by one for the next iteration
i <- i + 1
}
warnings()
str(dScores)
mean(dScores$d_score, na.rm = T)
